<html>
  <head>
    <meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Alpine.js 中文文档 | Jane&#39;s art center</title>
<link rel="shortcut icon" href="https://lovenini.art/favicon.ico?v=1591962176190">
<link href="https://cdn.jsdelivr.net/npm/remixicon@2.3.0/fonts/remixicon.css" rel="stylesheet">
<link rel="stylesheet" href="https://lovenini.art/styles/main.css">
<link rel="alternate" type="application/atom+xml" title="Alpine.js 中文文档 | Jane&#39;s art center - Atom Feed" href="https://lovenini.art/atom.xml">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Droid+Serif:400,700">



    <meta name="description" content="Alpine.js 中文文档
Alpine.js 提供了像是 Vue 或 React 这样的大型框架的响应式或宣告式的特性，但使用成本却低得多。
你依然可以保留你的 DOM ，并且在你认为合适的时候添加行为。
您可以把 Alpine.js ..." />
    <meta name="keywords" content="alpinejs" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
    <script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
  </head>
  <body>
    <div class="main">
      <div class="main-content">
        <div class="site-header">
  <a href="https://lovenini.art">
  <img class="avatar" src="https://lovenini.art/images/avatar.png?v=1591962176190" alt="">
  </a>
  <h1 class="site-title">
    Jane&#39;s art center
  </h1>
  <p class="site-description">
    温故而知新
  </p>
  <div class="menu-container">
    
      
        <a href="https://lovenini.art" class="menu">
          首页
        </a>
      
    
      
        <a href="/archives" class="menu">
          归档
        </a>
      
    
      
        <a href="/tags" class="menu">
          标签
        </a>
      
    
      
        <a href="/post/about" class="menu">
          关于
        </a>
      
    
  </div>
  <div class="social-container">
    
      
    
      
    
      
    
      
    
      
    
  </div>
</div>

        <div class="post-detail">
          <article class="post">
            <h2 class="post-title">
              Alpine.js 中文文档
            </h2>
            <div class="post-info">
              <span>
                2020-06-11
              </span>
              <span>
                26 min read
              </span>
              
                <a href="https://lovenini.art/tag/alpinejs/" class="post-tag">
                  # alpinejs
                </a>
              
            </div>
            
            <div class="post-content-wrapper">
              <div class="post-content">
                <h1 id="alpinejs-中文文档">Alpine.js 中文文档</h1>
<p>Alpine.js 提供了像是 Vue 或 React 这样的大型框架的响应式或宣告式的特性，但使用成本却低得多。</p>
<p>你依然可以保留你的 DOM ，并且在你认为合适的时候添加行为。</p>
<p>您可以把 Alpine.js 可选成 JavaScript 的<a href="https://tailwindcss.com/">Tailwind</a> 。</p>
<blockquote>
<p>备注：这个工具的语法几乎借鉴了<a href="https://vuejs.org/">Vue</a> （以及一些<a href="https://angularjs.org/">Angular</a>的延伸）。 我永远感谢他们为 Web 带来的大礼。</p>
</blockquote>
<!-- more -->
<h1 id="部署">部署</h1>
<p><strong>使用 CDN 来源：</strong></p>
<p>在你的  <code>&lt;head&gt;</code>  标签的末端添加以下脚本。</p>
<pre><code>&lt;script src=&quot;https://cdn.jsdelivr.net/gh/alpinejs/alpine@v2.x.x/dist/alpine.min.js&quot; defer&gt;&lt;/script&gt;
</code></pre>
<p>如果是正式环境，建议在链接中加入一个特定的版本号，避免新版本的升级造成你的程序执行错误。 举个例子，你想固定在 这个版本：<code>2.3.5</code></p>
<pre><code>&lt;script src=&quot;https://cdn.jsdelivr.net/gh/alpinejs/alpine@v2.3.5/dist/alpine.min.js&quot; defer&gt;&lt;/script&gt;
</code></pre>
<p><strong>使用 NPM 源：</strong></p>
<p>使用 NPM 程序包安装</p>
<pre><code>npm i alpinejs
</code></pre>
<p>在你的脚本中引入它。</p>
<pre><code>import 'alpinejs'
</code></pre>
<p><strong>对于 IE11 的支持</strong>请使用以下脚本替代。</p>
<pre><code>&lt;script type=&quot;module&quot; src=&quot;https://cdn.jsdelivr.net/gh/alpinejs/alpine@v2.x.x/dist/alpine.min.js&quot;&gt;&lt;/script&gt;
&lt;script nomodule src=&quot;https://cdn.jsdelivr.net/gh/alpinejs/alpine@v2.x.x/dist/alpine-ie11.min.js&quot; defer&gt;&lt;/script&gt;
</code></pre>
<p>上述的写法是<a href="https://philipwalton.com/articles/deploying-es2015-code-in-production-today/">module/nomodule 模式</a>，它会让现代化网页浏览器自动加载它所需的程序包。 而 IE11 版本的程序包将会在 IE11 上或者是其他的传统网页浏览器上被自动加载。</p>
<h2 id="使用">使用</h2>
<p><em>Dropdown/Modal</em></p>
<pre><code>&lt;div x-data=&quot;{ open: false }&quot;&gt;
    &lt;button @click=&quot;open = true&quot;&gt;Open Dropdown&lt;/button&gt;

    &lt;ul
        x-show=&quot;open&quot;
        @click.away=&quot;open = false&quot;
    &gt;
        Dropdown Body
    &lt;/ul&gt;
&lt;/div&gt;
</code></pre>
<p><strong>Tabs</strong></p>
<pre><code>&lt;div x-data=&quot;{ tab: 'foo' }&quot;&gt;
    &lt;button :class=&quot;{ 'active': tab === 'foo' }&quot; @click=&quot;tab = 'foo'&quot;&gt;Foo&lt;/button&gt;
    &lt;button :class=&quot;{ 'active': tab === 'bar' }&quot; @click=&quot;tab = 'bar'&quot;&gt;Bar&lt;/button&gt;

    &lt;div x-show=&quot;tab === 'foo'&quot;&gt;Tab Foo&lt;/div&gt;
    &lt;div x-show=&quot;tab === 'bar'&quot;&gt;Tab Bar&lt;/div&gt;
&lt;/div&gt;
</code></pre>
<p>你甚至可以用它来实现一些比较复杂的程序：<em>在悬停时预取下拉式菜单的 HTML 内容</em></p>
<pre><code>&lt;div x-data=&quot;{ open: false }&quot;&gt;
    &lt;button
        @mouseenter.once=&quot;
            fetch('/dropdown-partial.html')
                .then(response =&gt; response.text())
                .then(html =&gt; { $refs.dropdown.innerHTML = html })
        &quot;
        @click=&quot;open = true&quot;
    &gt;Show Dropdown&lt;/button&gt;

    &lt;div x-ref=&quot;dropdown&quot; x-show=&quot;open&quot; @click.away=&quot;open = false&quot;&gt;
        Loading Spinner...
    &lt;/div&gt;
&lt;/div&gt;
</code></pre>
<h2 id="教学">教学</h2>
<p>共有 13 个指令可供你使用：</p>
<table>
<thead>
<tr>
<th>指令</th>
<th>功能描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="https://github.com/alpinejs/alpine/blob/master/README_zh-TW.md#x-data"><code>x-data</code></a></td>
<td>声明一个新的组件范围。</td>
</tr>
<tr>
<td><a href="https://github.com/alpinejs/alpine/blob/master/README_zh-TW.md#x-init"><code>x-init</code></a></td>
<td>当一个组件初始化时，执行一个表达式。</td>
</tr>
<tr>
<td><a href="https://github.com/alpinejs/alpine/blob/master/README_zh-TW.md#x-show"><code>x-show</code></a></td>
<td>根据表达式的不同（true 或 false）切换元素是否显示。</td>
</tr>
<tr>
<td><a href="https://github.com/alpinejs/alpine/blob/master/README_zh-TW.md#x-bind"><code>x-bind</code></a></td>
<td>将属性的数值设定为 JS 表达式的结果。</td>
</tr>
<tr>
<td><a href="https://github.com/alpinejs/alpine/blob/master/README_zh-TW.md#x-on"><code>x-on</code></a></td>
<td>附加一个事件监听器到元素上，在触发时执行 JS 表达式。</td>
</tr>
<tr>
<td><a href="https://github.com/alpinejs/alpine/blob/master/README_zh-TW.md#x-model"><code>x-model</code></a></td>
<td>替元素附加「双向数据绑定」，同步输入元素与组件数据。</td>
</tr>
<tr>
<td><a href="https://github.com/alpinejs/alpine/blob/master/README_zh-TW.md#x-text"><code>x-text</code></a></td>
<td>类似于 <code>x-bind</code>，但会更新元素的 <code>innerText</code>。</td>
</tr>
<tr>
<td><a href="https://github.com/alpinejs/alpine/blob/master/README_zh-TW.md#x-html"><code>x-html</code></a></td>
<td>类似于 <code>x-bind</code> ，但会更新元素的 <code>innerHTML</code> 。</td>
</tr>
<tr>
<td><a href="https://github.com/alpinejs/alpine/blob/master/README_zh-TW.md#x-ref"><code>x-ref</code></a></td>
<td>便利地从组件中取得原始的 DOM 元素。</td>
</tr>
<tr>
<td><a href="https://github.com/alpinejs/alpine/blob/master/README_zh-TW.md#x-if"><code>x-if</code></a></td>
<td>从 DOM 中完全删除一个元素，需要在标签 <code>&lt;template&gt;</code> 上使用。</td>
</tr>
<tr>
<td><a href="https://github.com/alpinejs/alpine/blob/master/README_zh-TW.md#x-for"><code>x-for</code></a></td>
<td>替数组中的每项创建新的DOM节点，需要在标签 <code>&lt;template&gt;</code> 上使用。</td>
</tr>
<tr>
<td><a href="https://github.com/alpinejs/alpine/blob/master/README_zh-TW.md#x-transition"><code>x-transition</code></a></td>
<td>将 classes 应用于元素过渡的各个阶段的指令。</td>
</tr>
<tr>
<td><a href="https://github.com/alpinejs/alpine/blob/master/README_zh-TW.md#x-cloak"><code>x-cloak</code></a></td>
<td>此属性在 Alpine 初始化时将被移除，用于隐藏 预初始化的 DOM 。</td>
</tr>
</tbody>
</table>
<p>以及 6 种魔术属性：</p>
<table>
<thead>
<tr>
<th>魔术属性</th>
<th>功能描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="https://github.com/alpinejs/alpine/blob/master/README_zh-TW.md#el"><code>$el</code></a></td>
<td>检索根组件的DOM节点。</td>
</tr>
<tr>
<td><a href="https://github.com/alpinejs/alpine/blob/master/README_zh-TW.md#refs"><code>$refs</code></a></td>
<td>检索组件内标记 <code>x-ref</code> 的 DOM 元素。</td>
</tr>
<tr>
<td><a href="https://github.com/alpinejs/alpine/blob/master/README_zh-TW.md#event"><code>$event</code></a></td>
<td>检索事件监听器中的浏览器原生「Event」对象。</td>
</tr>
<tr>
<td><a href="https://github.com/alpinejs/alpine/blob/master/README_zh-TW.md#dispatch"><code>$dispatch</code></a></td>
<td>创建一个并在内部使用进行调度。<code>CustomEvent``.dispatchEvent()</code></td>
</tr>
<tr>
<td><a href="https://github.com/alpinejs/alpine/blob/master/README_zh-TW.md#nexttick"><code>$nextTick</code></a></td>
<td>在 Alpine 进行响应式 DOM 更新后执行给定的表达式。</td>
</tr>
<tr>
<td><a href="https://github.com/alpinejs/alpine/blob/master/README_zh-TW.md#watch"><code>$watch</code></a></td>
<td>当你监听的组件属性被改变时，执行回调方法。</td>
</tr>
</tbody>
</table>
<h3 id="指令">指令</h3>
<hr>
<h4 id="x-data"><code>x-data</code></h4>
<p><strong>例子:</strong> <code>&lt;div x-data=&quot;{ foo: 'bar' }&quot;&gt;...&lt;/div&gt;</code></p>
<p><strong>结构:</strong> <code>&lt;div x-data=&quot;[JSON data object]&quot;&gt;...&lt;/div&gt;</code></p>
<p><code>x-data</code> 声明了一个新的组件作用域，它通知框架使用对应的数据对象初始化一个新組件。</p>
<p>想想看，是不是就和 Vue 組件的 <code>data</code> 属性一样。</p>
<p><strong>提取组件逻辑</strong></p>
<p>你可以将数据（和特性）提取到可重用的函数中：</p>
<pre><code>&lt;div x-data=&quot;dropdown()&quot;&gt;
    &lt;button x-on:click=&quot;open&quot;&gt;Open&lt;/button&gt;

    &lt;div x-show=&quot;isOpen()&quot; x-on:click.away=&quot;close&quot;&gt;
        // Dropdown
    &lt;/div&gt;
&lt;/div&gt;

&lt;script&gt;
    function dropdown() {
        return {
            show: false,
            open() { this.show = true },
            close() { this.show = false },
            isOpen() { return this.show === true },
        }
    }
&lt;/script&gt;
</code></pre>
<blockquote>
<p><strong>对于 bundler 用户</strong>，得注意 Alpine.js 访问函数是在全局范围的（window），你需要显式地将你的函数赋给 window  ，以便通过 <code>x-data</code>  来使用它们。例如：<code>window.dropdown = function () {}</code>（这是因为使用 Webpack 、Rollup 与 Parcel 您定义的函数将默认为  module 的作用域而不是window ）。</p>
</blockquote>
<p>你也可以使用对象解构來混合多数据对象：</p>
<pre><code>&lt;div x-data=&quot;{...dropdown(), ...tabs()}&quot;&gt;
</code></pre>
<hr>
<h4 id="x-init"><code>x-init</code></h4>
<p><strong>例子:</strong> <code>&lt;div x-data=&quot;{ foo: 'bar' }&quot; x-init=&quot;foo = 'baz'&quot;&gt;&lt;/div&gt;</code></p>
<p><strong>结构:</strong> <code>&lt;div x-data=&quot;...&quot; x-init=&quot;[expression]&quot;&gt;&lt;/div&gt;</code></p>
<p><code>x-init</code> 在组件初始化时执行一个表达式。</p>
<p>如果你希望在 Alpine 对 DOM 更新之后，再执行表达式（类似于 VueJS 中的 mounted() 钩子），你可以返回一个回调函数</p>
<pre><code>x-init=&quot;() =&gt; { // 我们可以访问 post-dom-initialization 后的数据 // }&quot;
</code></pre>
<hr>
<h4 id="x-show"><code>x-show</code></h4>
<p><strong>例子:</strong> <code>&lt;div x-show=&quot;open&quot;&gt;&lt;/div&gt;</code></p>
<p><strong>结构:</strong> <code>&lt;div x-show=&quot;[expression]&quot;&gt;&lt;/div&gt;</code></p>
<pre><code>x-show  根据表达式结果来切换元素显示状态
</code></pre>
<p><strong>x-show.transition</strong></p>
<p><code>x-show.transition</code> 是一个便捷的使用CSS过渡的 API 。</p>
<pre><code>&lt;div x-show.transition=&quot;open&quot;&gt;
    These contents will be transitioned in and out.
&lt;/div&gt;
</code></pre>
<table>
<thead>
<tr>
<th>指令</th>
<th>功能描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>x-show.transition</code></td>
<td>同步淡出与缩放 （opacity， scale： 0.95， timing-function： cubic-bezier（0.4， 0.0， 0.2， 1）， duration-in： 150ms， duration-out： 75ms）</td>
</tr>
<tr>
<td><code>x-show.transition.in</code></td>
<td>只有「in」过渡。</td>
</tr>
<tr>
<td><code>x-show.transition.out</code></td>
<td>只有「out」过渡。</td>
</tr>
<tr>
<td><code>x-show.transition.opacity</code></td>
<td>只使用淡出。</td>
</tr>
<tr>
<td><code>x-show.transition.scale</code></td>
<td>只使用缩放。</td>
</tr>
<tr>
<td><code>x-show.transition.scale.75</code></td>
<td>自定 CSS 缩放 。<code>transform: scale(.75)</code></td>
</tr>
<tr>
<td><code>x-show.transition.duration.200ms</code></td>
<td>将「in」过渡设定为 200毫秒。 「out」将设定为 in 的一半（100 毫秒）。</td>
</tr>
<tr>
<td><code>x-show.transition.origin.top.right</code></td>
<td>自定义 CSS 过渡起始点.<code>transform-origin: top right</code></td>
</tr>
<tr>
<td><code>x-show.transition.in.duration.200ms.out.duration.50ms</code></td>
<td>「in」与「out」设定不同的持续时间。</td>
</tr>
</tbody>
</table>
<blockquote>
<p>备注：这些过渡的修饰符都是可以相互配合使用，这个例子是可行的（虽然很荒谬，呵呵）：<code>x-show.transition.in.duration.100ms.origin.top.right.opacity.scale.85.out.duration.200ms.origin.bottom.left.opacity.scale.95</code></p>
</blockquote>
<blockquote>
<p>备注：：<code>x-show</code> 会等待所有子元素完成过渡，如果你想省略这个行为，请添加 <code>.immediate</code>  修饰符</p>
</blockquote>
<pre><code>&lt;div x-show.immediate=&quot;open&quot;&gt;
    &lt;div x-show.transition=&quot;open&quot;&gt;
&lt;/div&gt;
</code></pre>
<hr>
<h4 id="x-bind"><code>x-bind</code></h4>
<blockquote>
<p>备注：你可以自由使用较短的&quot;：&quot; 语法：<code>:type=&quot;...&quot;</code></p>
</blockquote>
<p><strong>示例 ：</strong> <code>&lt;input x-bind:type=&quot;inputType&quot;&gt;</code></p>
<p><strong>结构 ：</strong> <code>&lt;input x-bind:[attribute]=&quot;[expression]&quot;&gt;</code></p>
<p><code>x-bind</code> 将一个属性值设定为 JavaScript 表达式的结果。 这个表达式可以访问组件的数据对象的所有键，并且每次更新数据时都会同步更新。</p>
<blockquote>
<p>备注：属性绑定只有在其依赖的关系被更新时才会更新，框架足够智能，观察到数据更改并检测哪些绑定关心它们。</p>
</blockquote>
<p><strong>用于类别属性的<code>x-bind</code></strong></p>
<pre><code>x-bind 与 `class` 属性在绑定时的行为会有点不同。
</code></pre>
<p>对于 classes 而言，当你传递一个键为 class 名称的对象，值则是 boolean表达式来决定是否应该要应用这些 class 。</p>
<p>举例来说： <code>&lt;div x-bind:class=&quot;{ 'hidden': foo }&quot;&gt;&lt;/div&gt;</code></p>
<p>在这个范例中，只有当 <code>foo</code> 为 <code>true</code>时，hidden 类别才会被应用。</p>
<p><strong>用于布尔属性的<code>x-bind</code></strong></p>
<pre><code>x-bind` 支持与数值属性相同的布尔属性，使用变量作为条件或任何可以解析为`true` or `false` 的JavaScript 表达式。
</code></pre>
<p>举例来说：</p>
<pre><code>&lt;!-- Given: --&gt;
&lt;button x-bind:disabled=&quot;myVar&quot;&gt;Click me&lt;/button&gt;

&lt;!-- When myVar == true: --&gt;
&lt;button disabled=&quot;disabled&quot;&gt;Click me&lt;/button&gt;

&lt;!-- When myVar == false: --&gt;
&lt;button&gt;Click me&lt;/button&gt;
</code></pre>
<p>这将在 <code>myVar 为true或false时分别添加或删除</code>disabled`属性。</p>
<p>布尔属性将支持符合<a href="https://html.spec.whatwg.org/multipage/indices.html#attributes-3:boolean-attribute">HTML规范</a>的属性，例如： disabled<code>、</code>readonly<code>、</code>required<code>、</code>checked<code>、</code>hidden<code>、</code>selected<code>、</code>open  等。</p>
<hr>
<h4 id="x-on"><code>x-on</code></h4>
<blockquote>
<p>备注：你可以自由使用较短的&quot;@」 语法：<code>@click=&quot;...&quot;</code></p>
</blockquote>
<p><strong>示例 ：</strong> <code>&lt;button x-on:click=&quot;foo = 'bar'&quot;&gt;&lt;/button&gt;</code></p>
<p><strong>结构 ：</strong> <code>&lt;button x-on:[event]=&quot;[expression]&quot;&gt;&lt;/button&gt;</code></p>
<p><code>x-on</code> 会将一个事件监听器附加在它所声明的元素上，当这个事件被触发时，在其值所设定的 JavaScript 表达式将会被执行。</p>
<p>如果任何数据在这个表达式中被修改，那么与这个被修改的数据所「绑定」的元素属性也会随着更新。</p>
<p>**<code>keydown</code>修饰符</p>
<p><strong>示例 ：</strong> <code>&lt;input type=&quot;text&quot; x-on:keydown.escape=&quot;open = false&quot;&gt;</code></p>
<p>你可以使用附加到 <code>x-on:keydown</code> 指令中的 keydown 修饰符，指定要监听的特定键值。 请注意，这些修饰符的命名方式是短横线连接式。</p>
<p>例如：  <code>enter</code>， <code>escape</code>， <code>arrow-up</code>， <code>arrow-down</code></p>
<blockquote>
<p>备注：你也可以监听系统修饰符的键值组合，例如：<code>x-on:keydown.cmd.enter=&quot;foo&quot;</code></p>
</blockquote>
<p><strong><code>.away</code>修饰符</strong></p>
<p><strong>范例：</strong> <code>&lt;div x-on:click.away=&quot;showModal = false&quot;&gt;&lt;/div&gt;</code></p>
<p>当 修饰符存在时，则仅当事件源自其自身或其子级以外的其他源时，才执行事件处理程序。</p>
<p>当用户点击 dropdowns and modals 时，这对于隐藏它们是非常有用的。</p>
<p><strong><code>.prevent</code>修饰器</strong></p>
<p><strong>范例：</strong> <code>&lt;input type=&quot;checkbox&quot; x-on:click.prevent&gt;</code></p>
<p>将.prevent添加到事件监听器将会在触发的事件上调用preventDefault。在上面的示例中，这意味着当用户单击该复选框时，它实际上不会被选中。</p>
<p><strong><code>.stop</code>修饰器</strong></p>
<p><strong>范例：</strong> <code>&lt;div x-on:click=&quot;foo = 'bar'&quot;&gt;&lt;button x-on:click.stop&gt;&lt;/button&gt;&lt;/div&gt;</code></p>
<p>将.stop添加到事件侦听器将在触发的事件上调用stopPropagation。在上面的示例中，这意味着“点击”事件不会从按钮到外部冒泡。换句话说，当用户单击按钮时，foo将不会设置为“ bar”。</p>
<p><strong><code>.self</code>修饰器</strong></p>
<p><strong>范例：</strong> <code>&lt;div x-on:click.self=&quot;foo = 'bar'&quot;&gt;&lt;button&gt;&lt;/button&gt;&lt;/div&gt;</code></p>
<p>如果$ event.target是元素本身，则将.self添加到事件侦听器将仅触发处理程序。在上面的示例中，这意味着从按钮到外部冒泡的“ click”事件将不会运行处理程序。</p>
<p><strong><code>.window</code>修饰器</strong></p>
<p><strong>范例：</strong> <code>&lt;div x-on:resize.window=&quot;isOpen = window.outerWidth &gt; 768 ? false : open&quot;&gt;&lt;/div&gt;</code></p>
<p>将.window添加到事件侦听器会将侦听器安装在全局窗口对象上，而不是在声明该侦听器的DOM节点上。当您希望随着窗口的变化（例如调整大小事件）而修改组件状态时，这很有用。在此示例中，当窗口变得大于768像素宽时，我们将关闭模式/下拉菜单，否则保持相同状态。</p>
<blockquote>
<p>备注：你也可以使用<code>.document</code> 修饰符，将监听器加入到 document 中，而不是加入到<code>window</code> 中。</p>
</blockquote>
<p><strong><code>.once</code>修饰器</strong></p>
<p><strong>范例：</strong> <code>&lt;button x-on:mouseenter.once=&quot;fetchSomething()&quot;&gt;&lt;/button&gt;</code></p>
<p>将.once修饰符添加到事件侦听器将确保该侦听器仅被处理一次。这对于只想执行一次的事情很有用，例如获取HTML局部等。</p>
<p><strong><code>.debounce</code>修饰器</strong></p>
<p><strong>范例：</strong> <code>&lt;input x-on:input.debounce=&quot;fetchSomething()&quot;&gt;</code></p>
<p>debounce修饰符使您给事件处理程序加上「防抖动机制。换句话说，事件处理程序要等到自上一次触发事件起经过一定时间后才会运行。准备好调用处理程序时，将执行最后一个处理程序调用。默认的 debounce 等待时间是 250 毫秒。</p>
<p>如果您希望对此进行自定义，则可以指定自定义等待时间，如下所示：</p>
<pre><code>&lt;input x-on:input.debounce.750=&quot;fetchSomething()&quot;&gt;
&lt;input x-on:input.debounce.750ms=&quot;fetchSomething()&quot;&gt;
</code></pre>
<hr>
<h4 id="x-model"><code>x-model</code></h4>
<p><strong>示例 ：</strong> <code>&lt;input type=&quot;text&quot; x-model=&quot;foo&quot;&gt;</code></p>
<p><strong>结构 ：</strong> <code>&lt;input type=&quot;text&quot; x-model=&quot;[data item]&quot;&gt;</code></p>
<p><code>x-model</code> 将“双向数据绑定”添加到元素。换句话说，输入元素的值将与组件的数据项的值保持同步。</p>
<blockquote>
<p>备注： <code>x-model</code>将会智能地察觉到 inputs 、 checkboxes 、 radio buttons 、 textareas 、 selects 以及 multiple selects 的变化。 在这些情形下，它的行为将会跟<a href="https://cn.vuejs.org/v2/guide/forms.html">Vue</a>有着一样的表现。</p>
</blockquote>
<p><strong><code>.debounce</code>修饰器</strong></p>
<p><strong>范例：</strong> <code>&lt;input x-model.debounce=&quot;search&quot;&gt;</code></p>
<p><code>debounce</code> 修饰器允许你替事件处理程序加上「防抖动」机制，换而言之，事件处理程序将不会立即被运作，它会自事件触发后等待一段时间才会开始运作。 当处理程序准备好被呼叫时，最后一个处理程序的呼叫将被执行。</p>
<p>默认的 debounce 等待时间是 250 毫秒。</p>
<p>如果你想自定义这个时间，可以像这样指定自定义的等待时间：</p>
<pre><code>&lt;input x-model.debounce.750=&quot;search&quot;&gt;
&lt;input x-model.debounce.750ms=&quot;search&quot;&gt;
</code></pre>
<hr>
<h4 id="x-text"><code>x-text</code></h4>
<p><strong>例子:</strong> <code>&lt;span x-text=&quot;foo&quot;&gt;&lt;/span&gt;</code></p>
<p><strong>结构:</strong> <code>&lt;span x-text=&quot;[expression]&quot;</code></p>
<pre><code>x-text 的工作原理与 x-bind 类似 ，只是它不會更新元素的值，而是更新元素的 innerText。
</code></pre>
<hr>
<h4 id="x-html"><code>x-html</code></h4>
<p><strong>例子:</strong> <code>&lt;span x-html=&quot;foo&quot;&gt;&lt;/span&gt;</code></p>
<p><strong>结构:</strong> <code>&lt;span x-html=&quot;[expression]&quot;</code></p>
<pre><code>x-text 的工作原理与 x-bind 类似，只是它不会更新元素的值，而是更新元素的 innerHTML。
</code></pre>
<blockquote>
<p>⚠️ <strong>只有在可信赖的内容使用这个特性，决定不要相信用户提供的内容</strong> ⚠️</p>
<p>使用第三方內容动态生成的 HTML 很容易导致 <a href="https://developer.mozilla.org/zh-TW/docs/Glossary/Cross-site_scripting">XSS</a> 漏洞的发生。</p>
</blockquote>
<hr>
<h4 id="x-ref"><code>x-ref</code></h4>
<p><strong>例子:</strong> <code>&lt;div x-ref=&quot;foo&quot;&gt;&lt;/div&gt;&lt;button x-on:click=&quot;$refs.foo.innerText = 'bar'&quot;&gt;&lt;/button&gt;</code></p>
<p><strong>结构:</strong> <code>&lt;div x-ref=&quot;[ref name]&quot;&gt;&lt;/div&gt;&lt;button x-on:click=&quot;$refs.[ref name].innerText = 'bar'&quot;&gt;&lt;/button&gt;</code></p>
<pre><code>x-ref` 提供了一個便利的方法让你从你的组件中获取到原始的 DOM 元素。通过在一個元素上设定一个`x-ref`属性，你就可以在 $refs 中调用所有的事件处理程序。
</code></pre>
<p>这是设置ID并在各处使用document.querySelector的有用替代方法。</p>
<blockquote>
<p>备注：如果你需要的话，也可以为 x-ref 绑定动态值： <code>&lt;span :x-ref=&quot;item.id&quot;&gt;&lt;/span&gt;</code></p>
<hr>
</blockquote>
<h4 id="x-if"><code>x-if</code></h4>
<p><strong>例子:</strong> <code>&lt;template x-if=&quot;true&quot;&gt;&lt;div&gt;Some Element&lt;/div&gt;&lt;/template&gt;</code></p>
<p><strong>结构:</strong> <code>&lt;template x-if=&quot;[expression]&quot;&gt;&lt;div&gt;Some Element&lt;/div&gt;&lt;/template&gt;</code></p>
<p>对于x-show不够的情况（x-show设置要显示的元素：如果为false，则不显示），可以使用x-if实际从DOM中完全删除元素。</p>
<p>在标签上使用 <code>x-if</code> 很重要，因为Alpine不使用虚拟DOM。此实现使Alpine保持坚固耐用，并使用真实的DOM发挥其魔力。</p>
<blockquote>
<p>备注：<code>x-if</code> 必须在<code>&lt;template&gt;&lt;/template&gt;</code>标签内拥有根元素。</p>
</blockquote>
<hr>
<h4 id="x-for"><code>x-for</code></h4>
<p><strong>示例 ：</strong></p>
<pre><code>&lt;template x-for=&quot;item in items&quot; :key=&quot;item&quot;&gt;
    &lt;div x-text=&quot;item&quot;&gt;&lt;/div&gt;
&lt;/template&gt;
</code></pre>
<blockquote>
<p>备注： <code>:key</code> 绑定是可选的，但强烈建议你使用。</p>
</blockquote>
<pre><code>如果要为数组中的每个项目创建新的DOM节点，则可以使用x-for。这应该类似于Vue中的v-for，但需要存在于模板标签上，而不是常规DOM元素上。
</code></pre>
<p>如果你想访问当前索引，请使用下列语法：</p>
<pre><code>&lt;template x-for=&quot;(item, index) in items&quot; :key=&quot;index&quot;&gt;
    &lt;!-- 如果你需要的话，也可以在迭代的內部引用「index」--&gt;
    &lt;div x-text=&quot;index&quot;&gt;&lt;/div&gt;
&lt;/template&gt;
</code></pre>
<blockquote>
<p>备注： <code>x-for</code>必须在<code>&lt;template&gt;&lt;/template&gt;</code>标签内拥有根元素的情形下使用。</p>
</blockquote>
<p>嵌套 <code>x-for</code></p>
<p>你也可以嵌套 <code>x-for</code> ，但你必须将每个循环都包裹在一个元素中，比如说：</p>
<pre><code>&lt;template x-for=&quot;item in items&quot;&gt;
    &lt;div&gt;
        &lt;template x-for=&quot;subItem in item.subItems&quot;&gt;
            &lt;div x-text=&quot;subItem&quot;&gt;&lt;/div&gt;
        &lt;/template&gt;
    &lt;/div&gt;
&lt;/template&gt;
</code></pre>
<hr>
<h4 id="x-transition"><code>x-transition</code></h4>
<p><strong>示例 ：</strong></p>
<pre><code>&lt;div
    x-show=&quot;open&quot;
    x-transition:enter=&quot;transition ease-out duration-300&quot;
    x-transition:enter-start=&quot;opacity-0 transform scale-90&quot;
    x-transition:enter-end=&quot;opacity-100 transform scale-100&quot;
    x-transition:leave=&quot;transition ease-in duration-300&quot;
    x-transition:leave-start=&quot;opacity-100 transform scale-100&quot;
    x-transition:leave-end=&quot;opacity-0 transform scale-90&quot;
&gt;...&lt;/div&gt;
&lt;template x-if=&quot;open&quot;&gt;
    &lt;div
        x-transition:enter=&quot;transition ease-out duration-300&quot;
        x-transition:enter-start=&quot;opacity-0 transform scale-90&quot;
        x-transition:enter-end=&quot;opacity-100 transform scale-100&quot;
        x-transition:leave=&quot;transition ease-in duration-300&quot;
        x-transition:leave-start=&quot;opacity-100 transform scale-100&quot;
        x-transition:leave-end=&quot;opacity-0 transform scale-90&quot;
    &gt;...&lt;/div&gt;
&lt;/template&gt;
</code></pre>
<blockquote>
<p>上述范例使用了<a href="https://tailwindcss.com/">Tailwind CSS</a>中的类别。</p>
</blockquote>
<p>Alpine提供了6种不同的过渡指令，用于将类应用于元素在“隐藏”状态和“显示”状态之间过渡的各个阶段。这些指令与x-show和x-if一起使用。</p>
<p>这些指令的行为与 VueJs 的过渡指令完全相同，除了它们有一个更加地合理名字：</p>
<table>
<thead>
<tr>
<th>指令</th>
<th>功能描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>:enter</code></td>
<td>在整个 entering 阶段中应用。</td>
</tr>
<tr>
<td><code>:enter-start</code></td>
<td>在元素插入前添加，在元素插入后删除一个帧。</td>
</tr>
<tr>
<td><code>:enter-end</code></td>
<td>元素在插入后添加一帧（同時刪除 ），在过渡／动画结束时刪除。</td>
</tr>
<tr>
<td><code>:leave</code></td>
<td>在整个 leaving 阶段中应用。</td>
</tr>
<tr>
<td><code>:leave-start</code></td>
<td>触发离开过渡时立即添加，在一帧后移除。</td>
</tr>
<tr>
<td><code>:leave-end</code></td>
<td>触发离开过渡后添加一帧（同时删除离开开始），在过渡/动画结束时删除。</td>
</tr>
</tbody>
</table>
<h4 id="x-cloak"><code>x-cloak</code></h4>
<p><strong>Example ：</strong> <code>&lt;div x-data=&quot;{}&quot; x-cloak&gt;&lt;/div&gt;</code></p>
<p>当Alpine初始化时，x-cloak属性将从元素中删除。这对于隐藏预初始化的DOM很有用。通常，添加以下全局样式才能使其正常工作：</p>
<pre><code>&lt;style&gt;
    [x-cloak] { display: none; }
&lt;/style&gt;
</code></pre>
<h3 id="魔术属性">魔术属性</h3>
<hr>
<blockquote>
<p>除了 $el 之外，<strong><code>x-data</code></strong> 中的魔术属性不可用，因为该组件尚未初始化。</p>
</blockquote>
<h4 id="el"><code>$el</code></h4>
<p><strong>示例 ：</strong></p>
<pre><code>&lt;div x-data&gt;
    &lt;button @click=&quot;$el.innerHTML = 'foo'&quot;&gt;Replace me with &quot;foo&quot;&lt;/button&gt;
&lt;/div&gt;
</code></pre>
<p><code>$el</code> 是一个魔术属性，可以用来检索根组件的 DOM 节点。</p>
<h4 id="refs"><code>$refs</code></h4>
<p><strong>示例 ：</strong></p>
<pre><code>&lt;span x-ref=&quot;foo&quot;&gt;&lt;/span&gt;

&lt;button x-on:click=&quot;$refs.foo.innerText = 'bar'&quot;&gt;&lt;/button&gt;

</code></pre>
<p>$ refs是一个魔术属性，可用于检索组件内部标有x-ref的DOM元素。当您需要手动操作DOM元素时，这很有用。</p>
<h4 id="event"><code>$event</code></h4>
<p><strong>示例 ：</strong></p>
<pre><code>&lt;input x-on:input=&quot;alert($event.target.value)&quot;&gt;
</code></pre>
<p>$ event是一个魔术属性，可以在事件侦听器中使用它来检索本机浏览器“ Event”对象。</p>
<blockquote>
<p>注意：$ event属性仅在DOM中可用。</p>
</blockquote>
<p>如果您需要在JavaScript函数中访问$ event，则可以直接将其传递：</p>
<pre><code>&lt;button x-on:click=&quot;myFunction($event)&quot;&gt;&lt;/button&gt;
</code></pre>
<h4 id="dispatch"><code>$dispatch</code></h4>
<p><strong>示例 ：</strong></p>
<pre><code>&lt;div @custom-event=&quot;console.log($event.detail.foo)&quot;&gt;
    &lt;button @click=&quot;$dispatch('custom-event', { foo: 'bar' })&quot;&gt;
    &lt;!-- When clicked, will console.log &quot;bar&quot; --&gt;
&lt;/div&gt;

</code></pre>
<p>$ dispatch是创建CustomEvent并在内部使用.dispatchEvent（）调度它的快捷方式。有很多很好的用例，可以使用自定义事件在组件之间以及组件之间传递数据。 <a href="https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent/detail">在此阅读</a> 有关浏览器中CustomEvent系统的更多信息。</p>
<p>你可能发现了，任何作为第二个参数传入到的数据，都会通过新的事件「detail」属性提供提供： 。 将自定义的事件资料附加到 属性是浏览器中的标准做法。 <a href="https://developer.mozilla.org/zh-TW/docs/Web/API/CustomEvent/detail">阅读这里</a>了解更多信息。<code>$dispatch('some-event', { some: 'data' })``$event.detail.some``.detail``CustomEvent</code></p>
<p>你也可以使用 $dispatch() 来触发 所绑定的数据更新，比如说：</p>
<pre><code>&lt;div x-data=&quot;{ foo: 'bar' }&quot;&gt;
    &lt;span x-model=&quot;foo&quot;&gt;
        &lt;button @click=&quot;$dispatch('input', 'baz')&quot;&gt;
        &lt;!-- After the button is clicked, `x-model` will catch the bubbling &quot;input&quot; event, and update foo to &quot;baz&quot;. --&gt;
    &lt;/span&gt;
&lt;/div&gt;
</code></pre>
<hr>
<h4 id="nexttick"><code>$nextTick</code></h4>
<p><strong>示例 ：</strong></p>
<pre><code>&lt;div x-data=&quot;{ fruit: 'apple' }&quot;&gt;
    &lt;button
        x-on:click=&quot;
            fruit = 'pear';
            $nextTick(() =&gt; { console.log($event.target.innerText) });
        &quot;
        x-text=&quot;fruit&quot;
    &gt;&lt;/button&gt;
&lt;/div&gt;
</code></pre>
<p>$ nextTick是一个神奇的属性，允许您仅在Alpine完成反应式DOM更新后才执行给定的表达式。这在您想要与DOM状态进行交互之后反映出所做的任何数据更新时非常有用。</p>
<h4 id="watch"><code>$watch</code></h4>
<p><strong>示例 ：</strong></p>
<pre><code>&lt;div x-data=&quot;{ open: false }&quot; x-init=&quot;$watch('open', value =&gt; console.log(value))&quot;&gt;
    &lt;button @click=&quot;open = ! open&quot;&gt;Toggle Open&lt;/button&gt;
&lt;/div&gt;
</code></pre>
<p>您可以使用$ watch magic方法“监视”组件属性。在上面的示例中，当单击按钮并更改了打开时，将触发提供的回调并console.log新值。</p>
<h2 id="安全">安全</h2>
<p>如果你发现了安全漏洞，请发送电子邮件至<a href="https://github.com/alpinejs/alpine/blob/master">calebporzio@gmail.com</a> 。</p>
<p>Alpine依靠使用Function对象的自定义实现来评估其指令。尽管比eval（）更安全，但在某些环境（例如Google Chrome应用）中，使用限制性内容安全策略（CSP）禁止使用它。</p>
<p>如果您在处理敏感数据并需要CSP的网站中使用Alpine，则需要在策略中包括不安全评估。正确配置的可靠策略将有助于在使用个人或财务数据时保护用户。</p>
<p>由于政策适用于您页面中的所有脚本，因此请务必仔细查看网站中包含的其他外部库，以确保它们值得信赖，并且不会使用eval（）函数或操作任何跨站脚本漏洞，这一点很重要。 DOM将恶意代码注入您的网页。</p>
<h2 id="v3-路线图">V3 路线图</h2>
<ul>
<li>Move from <code>x-ref</code> to <code>ref</code> for Vue parity?</li>
<li>Add <code>Alpine.directive()</code></li>
<li>Add <code>Alpine.component('foo', {...})</code> (With magic <code>__init()</code> method)</li>
<li>Dispatch Alpine events for &quot;loaded&quot;, &quot;transition-start&quot;, etc... (<a href="https://github.com/alpinejs/alpine/pull/299">#299</a>) ?</li>
<li>Remove &quot;object&quot; (and array) syntax from <code>x-bind:class=&quot;{ 'foo': true }&quot;</code> (<a href="https://github.com/alpinejs/alpine/pull/236">#236</a> to add support for object syntax for the <code>style</code> attribute)</li>
<li>Improve <code>x-for</code> mutation reactivity (<a href="https://github.com/alpinejs/alpine/pull/165">#165</a>)</li>
<li>Add &quot;deep watching&quot; support in V3 (<a href="https://github.com/alpinejs/alpine/pull/294">#294</a>)</li>
<li>Add <code>$el</code> shortcut</li>
<li>Change <code>@click.away</code> to <code>@click.outside</code>?</li>
</ul>
<h2 id="授权条款">授权条款</h2>
<p>Copyright © 2019-2020 Caleb Porzio and contributors</p>
<p>Licensed under the MIT license， see <a href="https://github.com/alpinejs/alpine/blob/master/LICENSE.md">LICENSE.md</a> for details.</p>
<h2 id="翻译对照表">翻译对照表</h2>
<table>
<thead>
<tr>
<th>英文</th>
<th>文档采用译名</th>
</tr>
</thead>
<tbody>
<tr>
<td>animation</td>
<td>动画</td>
</tr>
<tr>
<td>binding</td>
<td>绑定</td>
</tr>
<tr>
<td>callback</td>
<td>回调</td>
</tr>
<tr>
<td>components</td>
<td>组件</td>
</tr>
<tr>
<td>declarative</td>
<td>声明式</td>
</tr>
<tr>
<td>destructuring</td>
<td>解构</td>
</tr>
<tr>
<td>debounce</td>
<td>防抖动</td>
</tr>
<tr>
<td>dropdown</td>
<td>下拉式菜单</td>
</tr>
<tr>
<td>expression</td>
<td>表达式</td>
</tr>
<tr>
<td>handler</td>
<td>处理器</td>
</tr>
<tr>
<td>insert</td>
<td>插入</td>
</tr>
<tr>
<td>kebab-case</td>
<td>短横线连接式</td>
</tr>
<tr>
<td>listener</td>
<td>监听器</td>
</tr>
<tr>
<td>modifier</td>
<td>修饰符</td>
</tr>
<tr>
<td>modals</td>
<td>交互式窗口</td>
</tr>
<tr>
<td>nesting</td>
<td>嵌套</td>
</tr>
<tr>
<td>package</td>
<td>软件包</td>
</tr>
<tr>
<td>reactive</td>
<td>响应式</td>
</tr>
<tr>
<td>tabs</td>
<td>tabs</td>
</tr>
<tr>
<td>transition</td>
<td>过渡</td>
</tr>
<tr>
<td>two-way data binding</td>
<td>双向数据绑定</td>
</tr>
</tbody>
</table>

              </div>
              <div class="toc-container">
                <ul class="markdownIt-TOC">
<li><a href="#alpinejs-%E4%B8%AD%E6%96%87%E6%96%87%E6%A1%A3">Alpine.js 中文文档</a></li>
<li><a href="#%E9%83%A8%E7%BD%B2">部署</a>
<ul>
<li><a href="#%E4%BD%BF%E7%94%A8">使用</a></li>
<li><a href="#%E6%95%99%E5%AD%A6">教学</a>
<ul>
<li><a href="#%E6%8C%87%E4%BB%A4">指令</a>
<ul>
<li><a href="#x-data"><code>x-data</code></a></li>
<li><a href="#x-init"><code>x-init</code></a></li>
<li><a href="#x-show"><code>x-show</code></a></li>
<li><a href="#x-bind"><code>x-bind</code></a></li>
<li><a href="#x-on"><code>x-on</code></a></li>
<li><a href="#x-model"><code>x-model</code></a></li>
<li><a href="#x-text"><code>x-text</code></a></li>
<li><a href="#x-html"><code>x-html</code></a></li>
<li><a href="#x-ref"><code>x-ref</code></a></li>
<li><a href="#x-if"><code>x-if</code></a></li>
<li><a href="#x-for"><code>x-for</code></a></li>
<li><a href="#x-transition"><code>x-transition</code></a></li>
<li><a href="#x-cloak"><code>x-cloak</code></a></li>
</ul>
</li>
<li><a href="#%E9%AD%94%E6%9C%AF%E5%B1%9E%E6%80%A7">魔术属性</a>
<ul>
<li><a href="#el"><code>$el</code></a></li>
<li><a href="#refs"><code>$refs</code></a></li>
<li><a href="#event"><code>$event</code></a></li>
<li><a href="#dispatch"><code>$dispatch</code></a></li>
<li><a href="#nexttick"><code>$nextTick</code></a></li>
<li><a href="#watch"><code>$watch</code></a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E5%AE%89%E5%85%A8">安全</a></li>
<li><a href="#v3-%E8%B7%AF%E7%BA%BF%E5%9B%BE">V3 路线图</a></li>
<li><a href="#%E6%8E%88%E6%9D%83%E6%9D%A1%E6%AC%BE">授权条款</a></li>
<li><a href="#%E7%BF%BB%E8%AF%91%E5%AF%B9%E7%85%A7%E8%A1%A8">翻译对照表</a></li>
</ul>
</li>
</ul>

              </div>
            </div>
          </article>
        </div>

        
          <div class="next-post">
            <div class="next">下一篇</div>
            <a href="https://lovenini.art/post/hello-gridea/">
              <h3 class="post-title">
                Hello Gridea
              </h3>
            </a>
          </div>
        

        
          
            <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
<script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

<div id="gitalk-container"></div>

<script>

  var gitalk = new Gitalk({
    clientID: '39d9467435e5d7b0f536',
    clientSecret: '4f313276e687a90814344ace768e3324a7f4363c',
    repo: 'blogdiscuss',
    owner: 'janesart',
    admin: ['janesart'],
    id: (location.pathname).substring(0, 49),      // Ensure uniqueness and length less than 50
    distractionFreeMode: false  // Facebook-like distraction free mode
  })

  gitalk.render('gitalk-container')

</script>

          

          
        

        <div class="site-footer">
  Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a>
  <a class="rss" href="https://lovenini.art/atom.xml" target="_blank">
    <i class="ri-rss-line"></i> RSS
  </a>
</div>

      </div>
    </div>

    <script>
      hljs.initHighlightingOnLoad()

      let mainNavLinks = document.querySelectorAll(".markdownIt-TOC a");

      // This should probably be throttled.
      // Especially because it triggers during smooth scrolling.
      // https://lodash.com/docs/4.17.10#throttle
      // You could do like...
      // window.addEventListener("scroll", () => {
      //    _.throttle(doThatStuff, 100);
      // });
      // Only not doing it here to keep this Pen dependency-free.

      window.addEventListener("scroll", event => {
        let fromTop = window.scrollY;

        mainNavLinks.forEach((link, index) => {
          let section = document.getElementById(decodeURI(link.hash).substring(1));
          let nextSection = null
          if (mainNavLinks[index + 1]) {
            nextSection = document.getElementById(decodeURI(mainNavLinks[index + 1].hash).substring(1));
          }
          if (section.offsetTop <= fromTop) {
            if (nextSection) {
              if (nextSection.offsetTop > fromTop) {
                link.classList.add("current");
              } else {
                link.classList.remove("current");    
              }
            } else {
              link.classList.add("current");
            }
          } else {
            link.classList.remove("current");
          }
        });
      });

    </script>
  </body>
</html>
